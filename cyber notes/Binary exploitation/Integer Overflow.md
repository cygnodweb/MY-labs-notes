# ğŸ“š Integer Overflow: Full Notes

---

## ğŸ§  1. What is Integer Overflow?

**Integer Overflow** occurs when an arithmetic operation exceeds the maximum (or minimum) value a variable type can store, causing a **wraparound**.

### ğŸ”¥ Example (32-bit signed int):

vbnet
`Max:  2,147,483,647 Value: 2,147,483,647 + 1 â†’ -2,147,483,648 (Wraps around to negative)`

---

## ğŸ§ª 2. Why Is This Dangerous?

- Can bypass security checks (e.g., size validations).
    
- Leads to **buffer overflows**, **heap corruption**, **information leaks**.
    
- Often used in **heap exploitation**, **length miscalculations**, **memory allocation flaws**.
    

---

## âš™ï¸ 3. Types of Integer Vulnerabilities

|Type|Description|
|---|---|
|**Integer Overflow**|Value exceeds max limit and wraps|
|**Integer Underflow**|Value goes below minimum and wraps|
|**Signedness Bug**|Signed vs. unsigned comparisons cause logic issues|
|**Truncation**|Large integers cut down when cast to smaller types|

---

## ğŸ§¬ 4. Integer Types and Limits

| Type       | Range                           |
| ---------- | ------------------------------- |
| `int32_t`  | -2,147,483,648 to 2,147,483,647 |
| `uint32_t` | 0 to 4,294,967,295              |
| `int16_t`  | -32,768 to 32,767               |
| `uint16_t` | 0 to 65,535                     |

Use `limits.h` (C) or `stdint.h` to find limits.

---

## âœ… 5. Vulnerable Code Examples

### C Example:
`#include <stdio.h> #include <stdlib.h>  int main() {     unsigned int len;     scanf("%u", &len);      // Potential overflow: len * sizeof(int)     int *arr = malloc(len * sizeof(int));     if (arr == NULL) {         printf("Memory allocation failed\n");         return 1;     }      // Do something with arr     free(arr); }`

### Problem:

If `len * 4` exceeds `UINT_MAX`, it wraps around and allocates less memory, leading to heap corruption.

---

## ğŸ”¥ 6. Exploitation Use Cases

### ğŸ“Œ Use in Exploits:

- **Bypass malloc() checks** with fake small size.
    
- Trigger **buffer overflows** using under-allocated buffers.
    
- Leverage **negative indexing** via signedness bugs.
    
- Use in **ROP / shellcode offsets**.
    

---

## ğŸ§  7. Signed vs Unsigned Bugs

### C Code Example:

c

`int size; scanf("%d", &size);  if (size < 100) {    char *buf = malloc(size); }`

ğŸ§ª Exploit:

- Enter a negative number (e.g., `-1`)
    
- `malloc(-1)` = huge unsigned value â†’ DoS or overflow
    

---

## ğŸ› ï¸ 8. Detection Techniques

- Look for arithmetic operations: `+`, `-`, `*`, `<<`
    
- Trace allocation code using dynamic input
    
- Use fuzzers (e.g., AFL, libFuzzer) with arithmetic-based mutations
    
- Use static analyzers:
    
    - **C/C++**: Clangâ€™s UBSAN, Coverity, Fortify
        
    - **Python**: `mypy`, `bandit`
        
    - **Java**: `spotbugs`, `FindSecBugs`
        

---

## ğŸ§ª 9. Exploitation Tools

| Tool         | Purpose                            |
| ------------ | ---------------------------------- |
| AFL / AFL++  | Fuzzing input to trigger overflows |
| Valgrind     | Memory errors and heap leaks       |
| GDB + pwndbg | Debugging and inspecting wrapping  |
| angr         | Symbolic analysis of integer flaws |

---

## ğŸ§¼ 10. Prevention Best Practices

âœ… Do:

- Use **safe arithmetic libraries** (`SafeInt`, `Checked C`, etc.)
    
- Validate input ranges BEFORE operations
    
- Cast types correctly and safely
    
- Use compiler sanitizers:
    
    - `-fsanitize=undefined` or `-ftrapv` (GCC/Clang)
        

ğŸš« Donâ€™t:

- Assume multiplication or addition won't overflow
    
- Mix signed/unsigned without checks
    

---

## ğŸ“Œ 11. Real-World Vulnerabilities

|CVE ID|Description|
|---|---|
|CVE-2016-0636|Integer overflow in Java deserialization|
|CVE-2012-0769|Adobe Flash integer overflow â†’ RCE|
|CVE-2015-0286|OpenSSL ASN.1 structure integer overflow|
|CVE-2021-22945|Node.js integer overflow in Buffer.allocUnsafe|

---

## ğŸ§ª 12. CTF Challenge Ideas

|Challenge Name|Description|
|---|---|
|HeapMisfit|Exploitable `malloc()` from int overflow|
|SignedMadness|Signed vs unsigned bypass|
|OverflowShop|Integer checks bypass price validator|
|TruncateBug|Truncation overflow when downcasting|

---

## ğŸ§ª 13. Test Payloads / Input Ideas

- `0xFFFFFFFF`, `4294967295` (Max uint32)
    
- `-1`, `INT_MIN`, `INT_MAX`
    
- `99999999 * 99999999` (For overflow testing)
    
- Binary fuzzing patterns with arithmetic edge cases
    

---

## ğŸ§ª 14. Language-Specific Notes

### ğŸ Python:

- Python 3 ints auto-expand (no overflow), but logic bugs possible.
    

### â˜• Java:

- `int`, `long` overflow silently.
    
- Use `Math.addExact()` to detect overflow.
    

### ğŸ•³ï¸ C/C++:

- Overflow is undefined behavior for signed integers.
    
- Use `__builtin_add_overflow()` in modern GCC/Clang.
    

---

## ğŸ§  Summary

- Integer overflows are subtle but highly exploitable.
    
- They occur at **boundaries of type limits**.
    
- Combine with buffer or heap logic for powerful attacks.
    
- Use fuzzing + static analysis to find them.
    
- Prevent with safe math, correct type casting, and strict validation.